F00:0001       
F00:0002       ; This is the main file for assembly. Run all assembly code through this file.
F00:0003       ; > Set your tool in "options.asm"
F00:0004       ; > Set the src for your rom in "rom.asm"
F00:0005       
F00:0006       ; ====== options ====== ;
F00:0007               .include "options.asm"
F01:0001       ; set label to 1 iff using that tool
F01:0002       __VASM__                = 1
F01:0003       __KOWALSKI__            = 0
F01:0004       
F00:0008       
F00:0009               .if __VASM__ && __KOWALSKI__
F00:0010               .error "Cannot select both VASM and Kowalski"
F00:0011               .endif
F00:0012               .if !__VASM__ && !__KOWALSKI__
F00:0013               .error "Must select either VASM or Kowalski"
F00:0014               .endif
F00:0015       
F00:0016               ; VASM settings
F00:0017               .if __VASM__
F00:0018               .endif
F00:0019       
F00:0020               ; Kowalski settings
F00:0021               .if __KOWALSKI__
F00:0022               .opt Proc65c02, CaseSensitive, SwapBin
F00:0023               .endif
F00:0024       
F00:0025       ; ====== labels ====== ;
F00:0026               .include "macros.asm"
F02:0001       
F02:0002       ; Any macros with parameters must be added both for VASM and Kowalski's.
F02:0003       ; Note, they have slightly different syntax.
F02:0004       
F02:0005       
F02:0006       ; ====================== ;
F02:0007       ; ===== Kowalski's ===== ;
F02:0008       ; ====================== ;
F02:0009               .if __KOWALSKI__
F02:0010       ; ====================== ;
F02:0011       
F02:0012       ; ===== Missing from Kowalski's ===== ;
F02:0013       
F02:0014       ; stop
F02:0015       stp     .macro
F02:0016               .byte $db
F02:0017               .endm
F02:0018       
F02:0019       ; wait for interrupt
F02:0020       wai     .macro
F02:0021               .byte $cb
F02:0022               .endm
F02:0023       
F02:0024       ; ===== General ===== ;
F02:0025       
F02:0026       ; copy byte at src to dst
F02:0027       cp8     .macro src, dst
F02:0028               lda src
F02:0029               sta dst
F02:0030               .endm
F02:0031       
F02:0032       ; copy word at src to dst
F02:0033       cp16    .macro src, dst
F02:0034               cp8 src+1, dst+1 ; copy LSB
F02:0035               cp8 src, dst     ; COPY MSB
F02:0036               .endm
F02:0037       
F02:0038       ; swap bytes at t1 and t2
F02:0039       swp8    .macro t1, t2
F02:0040               lda t1
F02:0041               pha             ; stack.push( t1 )
F02:0042               lda t2
F02:0043               sta t1          ; t1 <= t2
F02:0044               pla
F02:0045               sta t2          ; t2 <= stack.pull()
F02:0046               .endm
F02:0047       
F02:0048       ; swap words at t1 and t2
F02:0049       swp16   .macro t1, t2
F02:0050               swp8P t1+1, t2+1
F02:0051               swp8P t1, t2
F02:0052               .endm
F02:0053       
F02:0054       ; increment memory with length
F02:0055       inc_mem .macro address, length
F02:0056               .if length < 1          ; ensure input is valid
F02:0057               .error "Bad memory size in inc_mem"
F02:0058               .endif
F02:0059       
F02:0060       .i      .set 0
F02:0061       
F02:0062               .repeat length-1        ; -------------------------------------- ;
F02:0063               inc address+.i
F02:0064               bne .end_inc            ; increment next if overflow occurred
F02:0065       .i      .set .i+1
F02:0066               .endr                   ; -------------------------------------- ;
F02:0067       
F02:0068               inc address+.i
F02:0069       
F02:0070       .end_inc:
F02:0071               .endm
F02:0072       
F02:0073       ; load label16 into dst16
F02:0074       ldlab16 .macro label16, dst16
F02:0075               lda #<label16
F02:0076               sta dst16
F02:0077               lda #>label16
F02:0078               sta dst16+1
F02:0079               .endm
F02:0080       
F02:0081       ; isolate "bit_i"th bit of "input"
F02:0082       get_bit .macro input, bit_i
F02:0083       .mask .set 1 << bit_i
F02:0084               lda #.mask
F02:0085               and input
F02:0086               .endm
F02:0087       
F02:0088       ; Set A to A != 0
F02:0089       sne     .macro
F02:0090               beq .exit       ; if 0, exit
F02:0091               lda #1
F02:0092       .exit
F02:0093               .endm
F02:0094       
F02:0095       ; Set A to A == 0
F02:0096       seq     .macro
F02:0097               sne
F02:0098               eor #1
F02:0099               .endm
F02:0100       
F02:0101       
F02:0102       
F02:0103       ; ====================== ;
F02:0104               .endif
F02:0105       ; ====================== ;
F02:0106       ; ======== VASM ======== ;
F02:0107       ; ====================== ;
F02:0108               .if __VASM__
F02:0109       ; ====================== ;
F02:0110       
F02:0111       ; ===== General ===== ;
F02:0112       
F02:0113       ; copy byte at src to dst
F02:0114       cp8     .macro src, dst
F02:0117       
F02:0118       
F02:0119       ; copy word at src to dst
F02:0120       cp16    .macro src, dst
F02:0123       
F02:0124       
F02:0125       ; swap bytes at t1 and t2
F02:0126       swp8    .macro t1, t2
F02:0133       
F02:0134       
F02:0135       ; swap words at t1 and t2
F02:0136       swp16   .macro t1, t2
F02:0139       
F02:0140       
F02:0141       ; increment memory with specified size
F02:0142       inc_mem .macro address, length
F02:0160       
F02:0161       
F02:0162       ; load label16 into dst16
F02:0163       ldlab16 .macro label16, dst16
F02:0169       
F02:0170       
F02:0171       ; isolate "bit_i"th bit of "input"
F02:0172       get_bit .macro input, bit_i
F02:0176       
F02:0177       
F02:0178       ; Set A to 1 iff A != 0
F02:0179       sne     .macro
F02:0183       
F02:0184       
F02:0185       ; Set A to 1 iff A == 0
F02:0186       seq     .macro
F02:0189       
F02:0190       
F02:0191       
F02:0192       ; ====================== ;
F02:0193               .endif
F02:0194       
F00:0027               .include "labels.asm"
F03:0001       
F03:0002       ; ===== Devices ===== ;
F03:0003       
F03:0004       ; VRAM
F03:0005       
F03:0006       _PMF1           = $3700 ; Pattern Memory Foreground page1
F03:0007       _PMF2           = $3800 ; Pattern Memory Foreground page2
F03:0008       _PMB1           = $3900 ; Pattern Memory Background page1
F03:0009       _PMB2           = $3a00 ; Pattern Memory Background page2
F03:0010       _NTBL1          = $3b00 ; Nametable page1
F03:0011       _NTBL2          = $3c00 ; Nametable page2
F03:0012       _NTBL3          = $3d00 ; Nametable page3
F03:0013       _NTBL4          = $3e00 ; Nametable page4
F03:0014       _NTBL_COLORS    = $3ec0 ; Nametable Colors
F03:0015       _OBM            = $3f00 ; Object Memory
F03:0016       
F03:0017       _FIRMWARE_START = $4000
F03:0018       
F03:0019       _ROM_START      = $8000
F03:0020       
F03:0021       ; ===== IO ===== ;
F03:0022       
F03:0023       _IO_START       = $7000
F03:0024       _IN_VBLANK      = $7000 ; 1 byte
F03:0025       _CLR_VBLANK_IRQ = $7001 ; 1 byte
F03:0026       
F03:0027       CONTROLLER_1    = $7002 ; 1 byte
F03:0028       CONTROLLER_2    = $7003 ; 1 byte
F03:0029       
F03:0030       RIGHT_BUTTON    = 0
F03:0031       LEFT_BUTTON     = 1
F03:0032       DOWN_BUTTON     = 2
F03:0033       UP_BUTTON       = 3
F03:0034       START_BUTTON    = 4
F03:0035       SELECT_BUTTON   = 5
F03:0036       B_BUTTON        = 6
F03:0037       A_BUTTON        = 7
F03:0038       
F03:0039       ; ===== VRAM Constants ===== ;
F03:0040       
F03:0041       BLACK_C         = %000
F03:0042       BLUE_C          = %001
F03:0043       GREEN_C         = %010
F03:0044       CYAN_C          = %011
F03:0045       RED_C           = %100
F03:0046       MAGENTA_C       = %101
F03:0047       YELLOW_C        = %110
F03:0048       WHITE_C         = %111
F03:0049       
F03:0050       BLACK_C0        = BLACK_C      << 0
F03:0051       BLUE_C0         = BLUE_C       << 0
F03:0052       GREEN_C0        = GREEN_C      << 0
F03:0053       CYAN_C0         = CYAN_C       << 0
F03:0054       RED_C0          = RED_C        << 0
F03:0055       MAGENTA_C0      = MAGENTA_C    << 0
F03:0056       YELLOW_C0       = YELLOW_C     << 0
F03:0057       WHITE_C0        = WHITE_C      << 0
F03:0058       
F03:0059       BLACK_C1        = BLACK_C      << 3
F03:0060       BLUE_C1         = BLUE_C       << 3
F03:0061       GREEN_C1        = GREEN_C      << 3
F03:0062       CYAN_C1         = CYAN_C       << 3
F03:0063       RED_C1          = RED_C        << 3
F03:0064       MAGENTA_C1      = MAGENTA_C    << 3
F03:0065       YELLOW_C1       = YELLOW_C     << 3
F03:0066       WHITE_C1        = WHITE_C      << 3
F03:0067       
F03:0068       COLOR_ALT       = %10000000
F03:0069       HFLIP           = %01000000
F03:0070       VFLIP           = %00100000
F03:0071       
F03:0072       ; ===== ROM Locations ===== ;
F03:0073       
F03:0074       reset           = $9000
F03:0075       do_logic        = $a000
F03:0076       fill_vram       = $b000
F03:0077       
F03:0078       
F00:0028       
F00:0029       ; ====== start ====== ;
F00:0030               .org 0
F00:0031       
F00:0032       ; ====== RAM ====== ;
F00:0033               .include "zero_page.asm"
F04:0001       ; ===== Zero Page ===== ;
F04:0002       
F04:0003       
F04:0004       INT8_G1:        .byte 1
               S01:00000000:  01
F04:0005       INT8_G2:        .byte 0
               S01:00000001:  00
F04:0006       INT8_G3:        .byte 0
               S01:00000002:  00
F04:0007       INT8_G4:        .byte 0
               S01:00000003:  00
F04:0008       INT8_G5:        .byte 0
               S01:00000004:  00
F04:0009       INT8_I1:        .byte 0
               S01:00000005:  00
F04:0010       INT8_I2:        .byte 0
               S01:00000006:  00
F04:0011       INT8_O:         .byte 0
               S01:00000007:  00
F04:0012       
F04:0013       INT16_G1:       .byte 0, 0
               S01:00000008:  00
               S01:00000009:  00
F04:0014       INT16_G2:       .byte 0, 0
               S01:0000000A:  00
               S01:0000000B:  00
F04:0015       INT16_G3:       .byte 0, 0
               S01:0000000C:  00
               S01:0000000D:  00
F04:0016       INT16_G4:       .byte 0, 0
               S01:0000000E:  00
               S01:0000000F:  00
F04:0017       INT16_G5:       .byte 0, 0
               S01:00000010:  00
               S01:00000011:  00
F04:0018       INT16_I1:       .byte 0, 0
               S01:00000012:  00
               S01:00000013:  00
F04:0019       INT16_I2:       .byte 0, 0
               S01:00000014:  00
               S01:00000015:  00
F04:0020       INT16_O:        .byte 0, 0
               S01:00000016:  00
               S01:00000017:  00
F04:0021       
F04:0022       Q9_6_G1:        .byte 0, 0
               S01:00000018:  00
               S01:00000019:  00
F04:0023       Q9_6_G2:        .byte 0, 0
               S01:0000001A:  00
               S01:0000001B:  00
F04:0024       Q9_6_G3:        .byte 0, 0
               S01:0000001C:  00
               S01:0000001D:  00
F04:0025       Q9_6_G4:        .byte 0, 0
               S01:0000001E:  00
               S01:0000001F:  00
F04:0026       Q9_6_G5:        .byte 0, 0
               S01:00000020:  00
               S01:00000021:  00
F04:0027       Q9_6_I1:        .byte 0, 0
               S01:00000022:  00
               S01:00000023:  00
F04:0028       Q9_6_I2:        .byte 0, 0
               S01:00000024:  00
               S01:00000025:  00
F04:0029       Q9_6_O:         .byte 0, 0
               S01:00000026:  00
               S01:00000027:  00
F04:0030       
F04:0031       ADDRESS16_1:    .byte 0, 0
               S01:00000028:  00
               S01:00000029:  00
F04:0032       ADDRESS16_2:    .byte 0, 0
               S01:0000002A:  00
               S01:0000002B:  00
F04:0033       ADDRESS16_3:    .byte 0, 0
               S01:0000002C:  00
               S01:0000002D:  00
F04:0034       ADDRESS16_4:    .byte 0, 0
               S01:0000002E:  00
               S01:0000002F:  00
F04:0035       
F04:0036       FRAME:          .byte 0, 0, 0, 0
               S01:00000030:  00
               S01:00000031:  00
               S01:00000032:  00
               S01:00000033:  00
F04:0037       
F00:0034       
F00:0035       ; ====== firmware ====== ;
F00:0036               .org _FIRMWARE_START
F00:0037               .include "firmware/header.asm"
F05:0001       
F05:0002               .byte "UCSB IEEE Arcade Machine 2021: firmware version: 0.3.0", 0
               S02:00004000:  55 43 53 42 20 49 45 45 45 20 41 72 63 61 64 65
               S02:00004010:  20 4D 61 63 68 69 6E 65 20 32 30 32 31 3A 20 66
               S02:00004020:  00
F05:0003       
F00:0038       
F00:0039               .include "firmware/interrupts.asm"
F06:0001       
F06:0002       ; NMI (disabled)
F06:0003       _handle_nmi:
F06:0004               rti
               S02:00004037:  40
F06:0005       
F06:0006       
F06:0007       
F06:0008       ; reset
F06:0009       _handle_reset:
F06:0010               sei                     ; disble irq by default
               S02:00004038:  78
F06:0011       
F06:0012               ; confirm that firmware is correct
F06:0013               ldlab16 _FIRMWARE_START, ADDRESS16_1
F07:0001       .label16_000007 .set _FIRMWARE_START
F07:0002               lda #<.label16_000007
               S02:00004039:  A9 00
F07:0003               sta ADDRESS16_1
               S02:0000403B:  85 28
F07:0004               lda #>.label16_000007
               S02:0000403D:  A9 40
F07:0005               sta ADDRESS16_1+1
               S02:0000403F:  85 29
F06:0014               ldlab16 _ROM_START, ADDRESS16_2
F08:0001       .label16_000008 .set _ROM_START
F08:0002               lda #<.label16_000008
               S02:00004041:  A9 00
F08:0003               sta ADDRESS16_2
               S02:00004043:  85 2A
F08:0004               lda #>.label16_000008
               S02:00004045:  A9 80
F08:0005               sta ADDRESS16_2+1
               S02:00004047:  85 2B
F06:0015               jsr strcmp
               S02:00004049:  20 3A 41
F06:0016               beq .continue
               S02:0000404C:  F0 01
F06:0017               stp
               S02:0000404E:  DB
F06:0018       .continue:
F06:0019       
F06:0020               ;  reset frame counter
F06:0021               lda #$ff
               S02:0000404F:  A9 FF
F06:0022               sta FRAME
               S02:00004051:  85 30
F06:0023               sta FRAME+1
               S02:00004053:  85 31
F06:0024               sta FRAME+2
               S02:00004055:  85 32
F06:0025               sta FRAME+3
               S02:00004057:  85 33
F06:0026       
F06:0027               ; game reset
F06:0028               jsr reset
               S02:00004059:  20 00 90
F06:0029       
F06:0030       _next_frame:    ; handle frame timing
F06:0031               inc_mem FRAME, 4        ; increment frame count
F09:0001               .if 4         < 1         ; ensure input is valid
F09:0002               .error "Bad memory size in inc_mem"
F09:0003               .endif
F09:0004       
F09:0005       .endinc .set .endinc_000009
F09:0006       .address .set FRAME
F09:0007       .i      .set 0
F09:0008       
F09:0009               .repeat 4        -1       ; -------------------------------------- ;
F09:0013       
F10:0001               inc .address+.i
               S02:0000405C:  E6 30
F10:0002               bne .endinc             ; increment next if overflow occurred
               S02:0000405E:  D0 0A
F10:0003       .i      .set .i+1
F10:0004               
F10:0001               inc .address+.i
               S02:00004060:  E6 31
F10:0002               bne .endinc             ; increment next if overflow occurred
               S02:00004062:  D0 06
F10:0003       .i      .set .i+1
F10:0004               
F10:0001               inc .address+.i
               S02:00004064:  E6 32
F10:0002               bne .endinc             ; increment next if overflow occurred
               S02:00004066:  D0 02
F10:0003       .i      .set .i+1
F10:0004               
F09:0014       
F09:0015               inc .address+.i
               S02:00004068:  E6 33
F09:0016       
F09:0017       .endinc_000009:
F06:0032               jsr do_logic            ; do non-vram logic
               S02:0000406A:  20 00 A0
F06:0033       
F06:0034               wai                     ; wait for interrupt
               S02:0000406D:  CB
F06:0035               cli                     ; enable irq (irq is immediately handled)
               S02:0000406E:  58
F06:0036               jsr fill_vram           ; enter fill_vram with interrupts on
               S02:0000406F:  20 00 B0
F06:0037               sei                     ; disble irq
               S02:00004072:  78
F06:0038               jmp _next_frame         ; repeat
               S02:00004073:  4C 5C 40
F06:0039       
F06:0040       
F06:0041       
F06:0042       ; IRQ
F06:0043       _handle_irq:
F06:0044       _vblank_irq:    ; wait for vblank; clear irq and return
F06:0045               pha
               S02:00004076:  48
F06:0046       
F06:0047       .check_if_in_vblank:
F06:0048               lda _IN_VBLANK
               S02:00004077:  AD 00 70
F06:0049               bne .in_vblank          ; if in vblank, return
               S02:0000407A:  D0 07
F06:0050               stz _CLR_VBLANK_IRQ     ; otherwise, clear interrupt,
               S02:0000407C:  9C 01 70
F06:0051               wai                     ;            wait for next interrupt
               S02:0000407F:  CB
F06:0052               jmp .check_if_in_vblank ;            and check again
               S02:00004080:  4C 77 40
F06:0053       
F06:0054       .in_vblank:
F06:0055               stz _CLR_VBLANK_IRQ     ; clear interrupt
               S02:00004083:  9C 01 70
F06:0056               pla
               S02:00004086:  68
F06:0057               rti
               S02:00004087:  40
F06:0058       
F00:0040       
F00:0041               .include "firmware/subroutines/add.asm"
F11:0001       
F11:0002       add8:
F11:0003               pha
               S02:00004088:  48
F11:0004       
F11:0005               clc
               S02:00004089:  18
F11:0006               lda INT8_I1
               S02:0000408A:  A5 05
F11:0007               adc INT8_I2
               S02:0000408C:  65 06
F11:0008               sta INT8_O      ; store sum
               S02:0000408E:  85 07
F11:0009       
F11:0010               pla
               S02:00004090:  68
F11:0011               rts
               S02:00004091:  60
F11:0012       
F11:0013       
F11:0014       add16:
F11:0015               pha
               S02:00004092:  48
F11:0016       
F11:0017               clc             ; clear carry
               S02:00004093:  18
F11:0018               lda INT16_I1
               S02:00004094:  A5 12
F11:0019               adc INT16_I2
               S02:00004096:  65 14
F11:0020               sta INT16_O     ; store sum of LSBs
               S02:00004098:  85 16
F11:0021               lda INT16_I1+1
               S02:0000409A:  A5 13
F11:0022               adc INT16_I2+1
               S02:0000409C:  65 15
F11:0023               sta INT16_O+1   ; store sum of MSBs
               S02:0000409E:  85 17
F11:0024       
F11:0025               pla
               S02:000040A0:  68
F11:0026               rts             ; return
               S02:000040A1:  60
F11:0027       
F11:0028       
F11:0029       addQ9_6:
F11:0030               pha
               S02:000040A2:  48
F11:0031       
F11:0032               clc             ; clear carry
               S02:000040A3:  18
F11:0033               lda Q9_6_I1
               S02:000040A4:  A5 22
F11:0034               adc Q9_6_I2
               S02:000040A6:  65 24
F11:0035               sta Q9_6_O     ; store sum of LSBs
               S02:000040A8:  85 26
F11:0036               lda Q9_6_I1+1
               S02:000040AA:  A5 23
F11:0037               adc Q9_6_I2+1
               S02:000040AC:  65 25
F11:0038               sta Q9_6_O+1   ; store sum of MSBs
               S02:000040AE:  85 27
F11:0039       
F11:0040               pla
               S02:000040B0:  68
F11:0041               rts             ; return
               S02:000040B1:  60
F11:0042       
F00:0042               .include "firmware/subroutines/subtract.asm"
F12:0001       
F12:0002       sub8:
F12:0003               pha
               S02:000040B2:  48
F12:0004       
F12:0005               sec
               S02:000040B3:  38
F12:0006               lda INT8_I1
               S02:000040B4:  A5 05
F12:0007               sbc INT8_I2
               S02:000040B6:  E5 06
F12:0008               sta INT8_O      ; store difference
               S02:000040B8:  85 07
F12:0009       
F12:0010               pla
               S02:000040BA:  68
F12:0011               rts
               S02:000040BB:  60
F12:0012       
F12:0013       
F12:0014       sub16:
F12:0015               pha
               S02:000040BC:  48
F12:0016       
F12:0017               sec
               S02:000040BD:  38
F12:0018               lda INT16_I1
               S02:000040BE:  A5 12
F12:0019               sbc INT16_I2
               S02:000040C0:  E5 14
F12:0020               sta INT16_O     ; store difference  of LSB
               S02:000040C2:  85 16
F12:0021               lda INT16_I1+1
               S02:000040C4:  A5 13
F12:0022               sbc INT16_I2+1
               S02:000040C6:  E5 15
F12:0023               sta INT16_O+1   ; store difference of MSBs
               S02:000040C8:  85 17
F12:0024       
F12:0025               pla
               S02:000040CA:  68
F12:0026               rts
               S02:000040CB:  60
F12:0027       
F12:0028       
F12:0029       subQ9_6:
F12:0030               pha
               S02:000040CC:  48
F12:0031       
F12:0032               sec
               S02:000040CD:  38
F12:0033               lda Q9_6_I1
               S02:000040CE:  A5 22
F12:0034               sbc Q9_6_I2
               S02:000040D0:  E5 24
F12:0035               sta Q9_6_O     ; store difference of LSB
               S02:000040D2:  85 26
F12:0036               lda Q9_6_I1+1
               S02:000040D4:  A5 23
F12:0037               sbc Q9_6_I2+1
               S02:000040D6:  E5 25
F12:0038               sta Q9_6_O+1   ; store difference of MSBs
               S02:000040D8:  85 27
F12:0039       
F12:0040               pla
               S02:000040DA:  68
F12:0041               rts
               S02:000040DB:  60
F12:0042       
F00:0043               .include "firmware/subroutines/multiply.asm"
F13:0001       
F13:0002       mul8:
F13:0003               pha
               S02:000040DC:  48
F13:0004       
F13:0005               ; TO DO
F13:0006       
F13:0007               pla
               S02:000040DD:  68
F13:0008               rts
               S02:000040DE:  60
F13:0009       
F13:0010       
F13:0011       mul16:
F13:0012               pha
               S02:000040DF:  48
F13:0013       
F13:0014               ; TO DO
F13:0015       
F13:0016               pla
               S02:000040E0:  68
F13:0017               rts
               S02:000040E1:  60
F13:0018       
F13:0019       
F13:0020       mulQ9_6:
F13:0021               pha
               S02:000040E2:  48
F13:0022       
F13:0023               ; TO DO
F13:0024       
F13:0025               pla
               S02:000040E3:  68
F13:0026               rts
               S02:000040E4:  60
F13:0027       
F00:0044               .include "firmware/subroutines/divide.asm"
F14:0001       
F14:0002       div8:
F14:0003               pha
               S02:000040E5:  48
F14:0004       
F14:0005               ; TO DO
F14:0006       
F14:0007               pla
               S02:000040E6:  68
F14:0008               rts
               S02:000040E7:  60
F14:0009       
F14:0010       
F14:0011       div16:
F14:0012               pha
               S02:000040E8:  48
F14:0013       
F14:0014               ; TO DO
F14:0015       
F14:0016               pla
               S02:000040E9:  68
F14:0017               rts
               S02:000040EA:  60
F14:0018       
F14:0019       
F14:0020       divQ9_6:
F14:0021               pha
               S02:000040EB:  48
F14:0022       
F14:0023               ; TO DO
F14:0024       
F14:0025               pla
               S02:000040EC:  68
F14:0026               rts
               S02:000040ED:  60
F14:0027       
F00:0045               .include "firmware/subroutines/misc_Q9_6.asm"
F15:0001       
F15:0002       
F15:0003       ; converts Q9_6_I1 to INT8_O
F15:0004       Q9_6_to_SINT8:
F15:0005               pha
               S02:000040EE:  48
F15:0006       
F15:0007               ; push lsb of Q9_6_I1
F15:0008               lda Q9_6_I1
               S02:000040EF:  A5 22
F15:0009               pha
               S02:000040F1:  48
F15:0010       
F15:0011               ; copy msb of Q9_6_I1 to out
F15:0012               cp8 Q9_6_I1+1, INT8_O
F16:0001               lda Q9_6_I1+1
               S02:000040F2:  A5 23
F16:0002               sta INT8_O
               S02:000040F4:  85 07
F15:0013       
F15:0014               rol Q9_6_I1
               S02:000040F6:  26 22
F15:0015               rol INT8_O
               S02:000040F8:  26 07
F15:0016               rol Q9_6_I1
               S02:000040FA:  26 22
F15:0017               rol INT8_O
               S02:000040FC:  26 07
F15:0018       
F15:0019               ; pull msb of Q9_6_I1
F15:0020               pla
               S02:000040FE:  68
F15:0021               sta Q9_6_I1
               S02:000040FF:  85 22
F15:0022       
F15:0023               pla
               S02:00004101:  68
F15:0024               rts
               S02:00004102:  60
F15:0025       
F15:0026       
F15:0027       
F15:0028       ; converts Q9_6_I1 to INT16_O
F15:0029       Q9_6_to_SINT16:
F15:0030               pha
               S02:00004103:  48
F15:0031       
F15:0032       
F15:0033               ; MSB
F15:0034               bit Q9_6_I1+1
               S02:00004104:  24 23
F15:0035       
F15:0036               ; sign extend
F15:0037               bmi .negative
               S02:00004106:  30 04
F15:0038       .positive:
F15:0039               lda #%00000000
               S02:00004108:  A9 00
F15:0040               bra .sign_done
               S02:0000410A:  80 02
F15:0041       .negative:
F15:0042               lda #%11111110
               S02:0000410C:  A9 FE
F15:0043       .sign_done:
F15:0044               sta INT16_O+1
               S02:0000410E:  85 17
F15:0045       
F15:0046               ; add 1 if 6th bit is set
F15:0047               lda #%01000000
               S02:00004110:  A9 40
F15:0048               bit Q9_6_I1+1
               S02:00004112:  24 23
F15:0049               beq .last_bit_handled
               S02:00004114:  F0 02
F15:0050               inc INT16_O+1
               S02:00004116:  E6 17
F15:0051       .last_bit_handled:
F15:0052       
F15:0053               ; LSB
F15:0054       
F15:0055               ; push lsb of Q9_6_I1
F15:0056               lda Q9_6_I1
               S02:00004118:  A5 22
F15:0057               pha
               S02:0000411A:  48
F15:0058       
F15:0059               cp8 Q9_6_I1+1, INT16_O
F17:0001               lda Q9_6_I1+1
               S02:0000411B:  A5 23
F17:0002               sta INT16_O
               S02:0000411D:  85 16
F15:0060       
F15:0061               rol Q9_6_I1
               S02:0000411F:  26 22
F15:0062               rol INT16_O
               S02:00004121:  26 16
F15:0063               rol Q9_6_I1
               S02:00004123:  26 22
F15:0064               rol INT16_O
               S02:00004125:  26 16
F15:0065       
F15:0066               ; pull msb of Q9_6_I1
F15:0067               pla
               S02:00004127:  68
F15:0068               sta Q9_6_I1
               S02:00004128:  85 22
F15:0069       
F15:0070               pla
               S02:0000412A:  68
F15:0071               rts
               S02:0000412B:  60
F15:0072       
F00:0046               .include "firmware/subroutines/transfer_mem.asm"
F18:0001       
F18:0002       ; copy memory with length INT8_I1 from ADDRESS16_1 to ADDRESS16_2
F18:0003       transfer_mem:
F18:0004               pha
               S02:0000412C:  48
F18:0005       
F18:0006               ldy #0
               S02:0000412D:  A0 00
F18:0007       .loop:
F18:0008               lda (ADDRESS16_1),Y
               S02:0000412F:  B1 28
F18:0009               sta (ADDRESS16_2),Y
               S02:00004131:  91 2A
F18:0010       
F18:0011               iny                     ; loop back if not at length
               S02:00004133:  C8
F18:0012               cpy INT8_I1
               S02:00004134:  C4 05
F18:0013               bne .loop
               S02:00004136:  D0 F7
F18:0014       
F18:0015               pla
               S02:00004138:  68
F18:0016               rts
               S02:00004139:  60
F18:0017       
F00:0047               .include "firmware/subroutines/string.asm"
F19:0001       
F19:0002       ; compare strings at ADDRESS16_1 and ADDRESS16_2 (not preserved)
F19:0003       ; put comparison in A
F19:0004       strcmp:
F19:0005               ldy #0
               S02:0000413A:  A0 00
F19:0006       .loop:
F19:0007               ; check if they are equal
F19:0008               lda (ADDRESS16_1),Y
               S02:0000413C:  B1 28
F19:0009               cmp (ADDRESS16_2),Y
               S02:0000413E:  D1 2A
F19:0010               bne .exit
               S02:00004140:  D0 10
F19:0011       
F19:0012               ; check if they are '\0'
F19:0013               lda #0
               S02:00004142:  A9 00
F19:0014               cmp (ADDRESS16_1),Y
               S02:00004144:  D1 28
F19:0015               beq .exit
               S02:00004146:  F0 0A
F19:0016       
F19:0017               ; increment address
F19:0018               iny
               S02:00004148:  C8
F19:0019               bne .loop
               S02:00004149:  D0 F1
F19:0020       .next:
F19:0021               ; add 256 to address
F19:0022               inc ADDRESS16_1+1
               S02:0000414B:  E6 29
F19:0023               inc ADDRESS16_2+1
               S02:0000414D:  E6 2B
F19:0024               jmp strcmp
               S02:0000414F:  4C 3A 41
F19:0025       .exit:
F19:0026               rts
               S02:00004152:  60
F19:0027       
F00:0048       
F00:0049       ; ====== IO ====== ;
F00:0050               .org _IO_START
F00:0051       
F00:0052               .include "fake_io.asm"
F20:0001       
F20:0002               .org _IN_VBLANK
F20:0003               .byte 1
               S03:00007000:  01
F20:0004       
F20:0005               .org _CLR_VBLANK_IRQ
F20:0006               .byte 0
               S04:00007001:  00
F20:0007       
F20:0008               .org CONTROLLER_1
F20:0009       ;              a
F20:0010       ;              |b
F20:0011       ;              ||select
F20:0012       ;              |||start
F20:0013       ;              ||||up
F20:0014       ;              |||||down
F20:0015       ;              ||||||left
F20:0016       ;              |||||||right
F20:0017               .byte %0000001
               S05:00007002:  01
F20:0018       
F20:0019               .org CONTROLLER_2
F20:0020       ;              a
F20:0021       ;              |b
F20:0022       ;              ||select
F20:0023       ;              |||start
F20:0024       ;              ||||up
F20:0025       ;              |||||down
F20:0026       ;              ||||||left
F20:0027       ;              |||||||right
F20:0028               .byte %00000000
               S06:00007003:  00
F20:0029       
F00:0053       
F00:0054       ; ====== ROM ====== ;
F00:0055               .org _ROM_START
F00:0056               .include "firmware/header.asm"
F21:0001       
F21:0002               .byte "UCSB IEEE Arcade Machine 2021: firmware version: 0.3.0", 0
               S07:00008000:  55 43 53 42 20 49 45 45 45 20 41 72 63 61 64 65
               S07:00008010:  20 4D 61 63 68 69 6E 65 20 32 30 32 31 3A 20 66
               S07:00008020:  00
F21:0003       
F00:0057       
F00:0058               .include "rom.asm"
F22:0001       
F22:0002       ; put your ROM path here:
F22:0003       
F22:0004               .include "template.asm"
F23:0001       
F23:0002       ;==========================;
F23:0003               .org reset
F23:0004       ;==========================;
F23:0005               rts
               S08:00009000:  60
F23:0006       
F23:0007       
F23:0008       ;==========================;
F23:0009               .org do_logic
F23:0010       ;==========================;
F23:0011               rts
               S09:0000A000:  60
F23:0012       
F23:0013       
F23:0014       ;==========================;
F23:0015               .org fill_vram
F23:0016       ;==========================;
F23:0017               rts
               S10:0000B000:  60
F23:0018       
F22:0005       
F00:0059               stp
               S10:0000B001:  DB
F00:0060       
F00:0061               ; set 65c02 vector locations
F00:0062               .org $fffa
F00:0063               .word _handle_nmi
               S11:0000FFFA:  37 40
F00:0064               .word _handle_reset
               S11:0000FFFC:  38 40
F00:0065               .word _handle_irq
               S11:0000FFFE:  76 40
F00:0066       


Sections:
S01  seg0
S02  seg4000
S03  seg7000
S04  seg7001
S05  seg7002
S06  seg7003
S07  seg8000
S08  seg9000
S09  sega000
S10  segb000
S11  segfffa


Sources:
F00  arcade.asm
F01  options.asm
F02  macros.asm
F03  labels.asm
F04  zero_page.asm
F05  firmware/header.asm
F06  firmware/interrupts.asm
F07  ldlab16
F08  ldlab16
F09  inc_mem
F10  REPEAT:inc_mem:line 13
F11  firmware/subroutines/add.asm
F12  firmware/subroutines/subtract.asm
F13  firmware/subroutines/multiply.asm
F14  firmware/subroutines/divide.asm
F15  firmware/subroutines/misc_Q9_6.asm
F16  cp8
F17  cp8
F18  firmware/subroutines/transfer_mem.asm
F19  firmware/subroutines/string.asm
F20  fake_io.asm
F21  firmware/header.asm
F22  rom.asm
F23  template.asm


Symbols:
 strcmp next EXPR(16715=0x414b) UNUSED ABS 
 strcmp exit EXPR(16722=0x4152) ABS 
 strcmp loop EXPR(16700=0x413c) ABS 
 transfer_mem loop EXPR(16687=0x412f) ABS 
transfer_mem EXPR(16684=0x412c) UNUSED ABS 
 Q9_6_to_SINT16 last_bit_handled EXPR(16664=0x4118) ABS 
 Q9_6_to_SINT16 sign_done EXPR(16654=0x410e) ABS 
 Q9_6_to_SINT16 positive EXPR(16648=0x4108) UNUSED ABS 
 Q9_6_to_SINT16 negative EXPR(16652=0x410c) ABS 
Q9_6_to_SINT16 EXPR(16643=0x4103) UNUSED ABS 
Q9_6_to_SINT8 EXPR(16622=0x40ee) UNUSED ABS 
divQ9_6 EXPR(16619=0x40eb) UNUSED ABS 
div16 EXPR(16616=0x40e8) UNUSED ABS 
div8 EXPR(16613=0x40e5) UNUSED ABS 
mulQ9_6 EXPR(16610=0x40e2) UNUSED ABS 
mul16 EXPR(16607=0x40df) UNUSED ABS 
mul8 EXPR(16604=0x40dc) UNUSED ABS 
subQ9_6 EXPR(16588=0x40cc) UNUSED ABS 
sub16 EXPR(16572=0x40bc) UNUSED ABS 
sub8 EXPR(16562=0x40b2) UNUSED ABS 
addQ9_6 EXPR(16546=0x40a2) UNUSED ABS 
add16 EXPR(16530=0x4092) UNUSED ABS 
add8 EXPR(16520=0x4088) UNUSED ABS 
 _vblank_irq in_vblank EXPR(16515=0x4083) ABS 
 _vblank_irq check_if_in_vblank EXPR(16503=0x4077) ABS 
_vblank_irq EXPR(16502=0x4076) UNUSED ABS 
_handle_irq EXPR(16502=0x4076) ABS 
 _next_frame i EXPR(3=0x3) 
 _next_frame address EXPR(48=0x30) 
 _next_frame endinc EXPR(16490=0x406a) 
 _next_frame endinc_000009 EXPR(16490=0x406a) ABS 
_next_frame EXPR(16476=0x405c) ABS 
 _handle_reset continue EXPR(16463=0x404f) ABS 
strcmp EXPR(16698=0x413a) ABS 
 _handle_reset label16_000008 EXPR(32768=0x8000) 
 _handle_reset label16_000007 EXPR(16384=0x4000) 
_handle_reset EXPR(16440=0x4038) ABS 
_handle_nmi EXPR(16439=0x4037) ABS 
FRAME EXPR(48=0x30) ABS 
ADDRESS16_4 EXPR(46=0x2e) UNUSED ABS 
ADDRESS16_3 EXPR(44=0x2c) UNUSED ABS 
ADDRESS16_2 EXPR(42=0x2a) ABS 
ADDRESS16_1 EXPR(40=0x28) ABS 
Q9_6_O EXPR(38=0x26) ABS 
Q9_6_I2 EXPR(36=0x24) ABS 
Q9_6_I1 EXPR(34=0x22) ABS 
Q9_6_G5 EXPR(32=0x20) UNUSED ABS 
Q9_6_G4 EXPR(30=0x1e) UNUSED ABS 
Q9_6_G3 EXPR(28=0x1c) UNUSED ABS 
Q9_6_G2 EXPR(26=0x1a) UNUSED ABS 
Q9_6_G1 EXPR(24=0x18) UNUSED ABS 
INT16_O EXPR(22=0x16) ABS 
INT16_I2 EXPR(20=0x14) ABS 
INT16_I1 EXPR(18=0x12) ABS 
INT16_G5 EXPR(16=0x10) UNUSED ABS 
INT16_G4 EXPR(14=0xe) UNUSED ABS 
INT16_G3 EXPR(12=0xc) UNUSED ABS 
INT16_G2 EXPR(10=0xa) UNUSED ABS 
INT16_G1 EXPR(8=0x8) UNUSED ABS 
INT8_O EXPR(7=0x7) ABS 
INT8_I2 EXPR(6=0x6) ABS 
INT8_I1 EXPR(5=0x5) ABS 
INT8_G5 EXPR(4=0x4) UNUSED ABS 
INT8_G4 EXPR(3=0x3) UNUSED ABS 
INT8_G3 EXPR(2=0x2) UNUSED ABS 
INT8_G2 EXPR(1=0x1) UNUSED ABS 
INT8_G1 EXPR(0=0x0) UNUSED ABS 
fill_vram EXPR(45056=0xb000) EQU 
do_logic EXPR(40960=0xa000) EQU 
reset EXPR(36864=0x9000) EQU 
VFLIP EXPR(32=0x20) UNUSED EQU 
HFLIP EXPR(64=0x40) UNUSED EQU 
COLOR_ALT EXPR(128=0x80) UNUSED EQU 
WHITE_C1 EXPR(56=0x38) UNUSED EQU 
YELLOW_C1 EXPR(48=0x30) UNUSED EQU 
MAGENTA_C1 EXPR(40=0x28) UNUSED EQU 
RED_C1 EXPR(32=0x20) UNUSED EQU 
CYAN_C1 EXPR(24=0x18) UNUSED EQU 
GREEN_C1 EXPR(16=0x10) UNUSED EQU 
BLUE_C1 EXPR(8=0x8) UNUSED EQU 
BLACK_C1 EXPR(0=0x0) UNUSED EQU 
WHITE_C0 EXPR(7=0x7) UNUSED EQU 
YELLOW_C0 EXPR(6=0x6) UNUSED EQU 
MAGENTA_C0 EXPR(5=0x5) UNUSED EQU 
RED_C0 EXPR(4=0x4) UNUSED EQU 
CYAN_C0 EXPR(3=0x3) UNUSED EQU 
GREEN_C0 EXPR(2=0x2) UNUSED EQU 
BLUE_C0 EXPR(1=0x1) UNUSED EQU 
BLACK_C0 EXPR(0=0x0) UNUSED EQU 
WHITE_C EXPR(7=0x7) EQU 
YELLOW_C EXPR(6=0x6) EQU 
MAGENTA_C EXPR(5=0x5) EQU 
RED_C EXPR(4=0x4) EQU 
CYAN_C EXPR(3=0x3) EQU 
GREEN_C EXPR(2=0x2) EQU 
BLUE_C EXPR(1=0x1) EQU 
BLACK_C EXPR(0=0x0) EQU 
A_BUTTON EXPR(7=0x7) UNUSED EQU 
B_BUTTON EXPR(6=0x6) UNUSED EQU 
SELECT_BUTTON EXPR(5=0x5) UNUSED EQU 
START_BUTTON EXPR(4=0x4) UNUSED EQU 
UP_BUTTON EXPR(3=0x3) UNUSED EQU 
DOWN_BUTTON EXPR(2=0x2) UNUSED EQU 
LEFT_BUTTON EXPR(1=0x1) UNUSED EQU 
RIGHT_BUTTON EXPR(0=0x0) UNUSED EQU 
CONTROLLER_2 EXPR(28675=0x7003) EQU 
CONTROLLER_1 EXPR(28674=0x7002) EQU 
_CLR_VBLANK_IRQ EXPR(28673=0x7001) EQU 
_IN_VBLANK EXPR(28672=0x7000) EQU 
_IO_START EXPR(28672=0x7000) EQU 
_ROM_START EXPR(32768=0x8000) EQU 
_FIRMWARE_START EXPR(16384=0x4000) EQU 
_OBM EXPR(16128=0x3f00) UNUSED EQU 
_NTBL_COLORS EXPR(16064=0x3ec0) UNUSED EQU 
_NTBL4 EXPR(15872=0x3e00) UNUSED EQU 
_NTBL3 EXPR(15616=0x3d00) UNUSED EQU 
_NTBL2 EXPR(15360=0x3c00) UNUSED EQU 
_NTBL1 EXPR(15104=0x3b00) UNUSED EQU 
_PMB2 EXPR(14848=0x3a00) UNUSED EQU 
_PMB1 EXPR(14592=0x3900) UNUSED EQU 
_PMF2 EXPR(14336=0x3800) UNUSED EQU 
_PMF1 EXPR(14080=0x3700) UNUSED EQU 
__KOWALSKI__ EXPR(0=0x0) EQU 
__VASM__ EXPR(1=0x1) EQU 
__RPTCNT EXPR(-1=0xffff) INTERNAL 
__VASM EXPR(0=0x0) INTERNAL 
__UNIXFS EXPR(0=0x0) INTERNAL 

There have been no errors.
